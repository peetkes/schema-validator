= schematron-test
:source-highlighter: rouge
:source-language: xslt
:icons: font

*Adjust MarkLogic Schematron validation so it can accept parameters during schematron transformation*

Did you ever wonder if it is possible to pass in external parameters during a schematron validation?

With the default iso-schematron it is not possible out-of-the-box. +
But as a schematron validation is in effect an xslt transformation, you should be able to pass in external parameters which can be used in a schematron rule/assert or report.

== ISO Schematron implementation in MarkLogic

The iso-schematron implementation used by MarkLogic consists of 4 xslt stylesheets and 1 xquery module:

* iso_dsdl_include.xsl, inclusion preprocessor for the non-smart text inclusions of ISO DSDL
* iso_abstract_expand.xsl, preprocessor which implements abstract patterns
* iso_schematron_skeleton_for_ML.xsl, scheleton module for ISO Schematron specific for use in MarkLogic
* iso_svrl_for_xslt2.xsl, implementation of Schematron Validation Report Language from ISO Schematron, imports the iso_schematron_skeleton_for_ML.xsl.
* sch-lib.xqy, definition of a document function that is used inside the iso_dsdl_include stylesheet to pull documents from the database

With these 5 components you can build a Schematron processor enirely in XSLT. It transforms a Schematron schema document into an XSLT stylesheet that can be applied to the xml document(s) to validate.

The following set of parameters can be set to influence the validation process:

.Schematron Parameters
[options="header"]
|===
| Parameter | Value | Description
| phase | NMTOKEN \| #ALL (default) | Select the phase for validation
| allow-foreign | true \| false (default)  | Pass non-Schematron elements and rich markup to the generated stylesheet
| diagnose | true (default) \| false  | Add the diagnostics to the assertion test in reports
| property | true (default) \| false | Experimental: Add properties to the assertion test in reports
| generate-paths | true (default) \| false | generate the @location attribute with XPaths
| sch.exslt.imports |  | semi-colon delimited string of filenames for some EXSLT implementations
| optimize | "visit-no-attributes" (default empty) | Use only when the schema has no attributes as the context nodes
| generate-fired-rule | true (default) \| false | Generate fired-rule elements
| terminate | true \| false (default) | Terminate on the first failed assertion or successful report
|===

First step is to apply the iso_dsdl_include.xsl stylesheet to the Schematron schema file. +
Second step is to apply the iso_abstract_expand.xsl stylesheet to the result of step1. +
The final step is to apply the iso_svrl_for_xslt2.xsl stylesheet to the result of step2.

## XQuery implementation in MarkLogic

The xquery implementation in MarkLogic consists of a set of xquery functions for compiling, storing, reading and executing the schematron validation.

- schematron:compile($schema, [$params]), compiles the schematron schema into a validator-xslt stylesheet and returns it
- schematron:delete($schematron-uri), deletes both the schematron schema from the schemas database and the validator-xslt stylesheet from the modules database
- schematron:get($schematron-uri), returns the validator-xslt from the modules database
- schematron:put($schematron-uri, [$params]), compiles the schematron schema from the schemas database and puts the generated validator-xslt into the modules database
- schematron:validate($document, validator-xslt), validates the given document against the given validator-xslt and returns the output of the validation in SVRL (Schematron Validation Report Language) format

As the default ISO Schematron implementation does not support passing parameters to the resulting schema validator xsl stylesheet, the xquery validation function also does not support that behaviour.

If we want to accomplish the passing of parameters into the validation process, we need to first make sure the validator-xslt stylesheet has a parameter that can be passed in in the validation method.
Fortunately we can accomplish that by extending the iso_svrl_for_xslt2.xsl stylesheet.

For this purpose we create a new wrapper for the default *iso_svrl_for_xslt2* implementation that imports the original *iso_svrl_for_xslt2* implementation and call that *iso_svrl_for_xslt2_wrapper.xsl*.

This file should overwrite the template *process-prolog* to also accept an extra parameter. See below `<axsl:param name="parameters"/>` on line 24

.Wrapper for default iso_svrl_for_xslt2 implementation
[source,xml,linenums,highlight='24']
----
<xsl:stylesheet
        xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:axsl="http://www.w3.org/1999/XSL/TransformAlias"
        xmlns:exsl="http://exslt.org/common"
        extension-element-prefixes="exsl"
        version="2.0">

  <xsl:import href="/MarkLogic/schematron/iso-schematron/iso_svrl_for_xslt2.xsl"/>

  <xsl:template name="processing-instruction">
    <xsl:copy-of select="./processing-instruction()" />
  </xsl:template>

  <xsl:template name="process-prolog">
    <xsl:call-template name="processing-instruction"/>
    <!--
      This is used to pass in a parameter map which can be used inside the schematron rules
      Param parameters is a map with key value items that can be used in the schematron rules.
      To access values from the map you should use map:get($parameters,'key').
      Make sure to add the following namespace definition into your schematron file:
      <sch:ns prefix="map" uri="http://marklogic.com/xdmp/map"/>
    -->
    <axsl:param name="parameters"/>

    <axsl:output method="xml" omit-xml-declaration="no" standalone="yes"
                 indent="yes">
      <xsl:if test=" string-length($output-encoding) &gt; 0">
        <xsl:attribute name="encoding"><xsl:value-of select=" $output-encoding" /></xsl:attribute>
      </xsl:if>
    </axsl:output>
  </xsl:template>

</xsl:stylesheet>
----

Next step is to create a custom module that wraps the original MarkLogic schematron:* functions mentioned in the list above. +
There are 2 functions that don't need to be changed, we can just create a default wrapper for those functions:

- schematron:get
_ schematron:delete

.Default xquery wrapper functions
[source,xquery]
----
xquery version "1.0-ml";
module namespace schematron = "http://marklogic.com/xdmp/my-schematron";
import module namespace ml-schematron="http://marklogic.com/xdmp/schematron" at "/MarkLogic/schematron/schematron.xqy";

declare option xdmp:mapping "false";

declare function schematron:get(
  $schematron-uri as xs:string
) as document-node()
{
  ml-schematron:get($schematron-uri)
};

declare function schematron:delete(
  $schematron-uri as xs:string
) as empty-sequence()
{
  ml-schematron:delete($schematron-uri)
};
----

.Override for MarkLogic schematron:compile, schematron:put and schematron:validate
[source,xquery]
----
xquery version "1.0-ml";
module namespace schematron = "http://marklogic.com/xdmp/my-schematron";
import module namespace ml-schematron="http://marklogic.com/xdmp/schematron" at "/MarkLogic/schematron/schematron.xqy";

declare namespace sch = "http://purl.oclc.org/dsdl/schematron";

declare option xdmp:mapping "false";

declare variable $TRACE_ID as xs:string := "koop-schematron";

declare variable $SVRL-FOR-XSLT2 := "iso-schematron/iso_svrl_for_xslt2_wrapper.xsl";
declare variable $INCLUDE := "/MarkLogic/schematron/iso-schematron/iso_dsdl_include.xsl";
declare variable $EXPAND := "/MarkLogic/schematron/iso-schematron/iso_abstract_expand.xsl";

(:~
 : Empty params wrapper for the schematron:compile function
 :
 : @param $schema     the schematron schema node to compile
 : @return The compiled schematron schema as validator-xslt
 :)
declare function schematron:compile(
    $schema as element(sch:schema)
) as document-node()
{
  schematron:compile($schema, ())
};

(:~
 : Compile Schematron schema and return the validator XSLT.
 : Default behaviour is no validation of the schematron schema
 : If schema validation is required, pass in a parameter key 'validate-schema' with value true
 : Throws an error if the schematron schema is bad
 :
 : @param $schema     the schematron schema node to compile
 : @param $params     map with parameters for the transformation
 : @return The compiled schematron schema as validator-xslt
 :)
declare function schematron:compile(
    $schema as element(sch:schema),
    $params as map:map?
) as document-node()
{
  let $step1 := xdmp:xslt-invoke($INCLUDE, document { $schema }, $params)

  let $validate-schema :=
    if (xs:string(map:get($params, "validate-schema"))="true")
    then validate full { $step1 }
    else ()

  let $step2 := xdmp:xslt-invoke($EXPAND, $step1, $params)
  let $validator-xslt := xdmp:xslt-invoke($SVRL-FOR-XSLT2, $step2, $params)
  return document { $validator-xslt }
};

(:~
 : Empty params wrapper for the schematron:put function
 :
 : @param $schematron-uri     the uro of the schematron schema in teh schemas database
 : @return empty-sequence
 :)
declare function schematron:put(
  $schematron-uri as xs:string
) as empty-sequence()
{
  schematron:put($schematron-uri, ())
};

(:~
 : Compile Schematron schema from Schemas database and store the compiled schema in modules database
 : Default behaviour is no validation of the schematron schema
 : If schema validation is required, pass in a parameter key 'validate-schema' with value true
 : Throws an error if the schematron schema is bad or cannot be found
 :
 : @param $schematron-uri     the uri of the schematron schema in teh schemas database
 : @param $params             map with parameters for the transformation
 : @return empty-sequence
 :)
declare function schematron:put(
  $schematron-uri as xs:string,
  $params as map:map?
) as empty-sequence()
{
  let $schema := xdmp:eval(
    $ml-schematron:get-schema,
    (xs:QName("schematron-uri"), $schematron-uri),
    <options xmlns="xdmp:eval">
      <database>{xdmp:schema-database()}</database>
    </options>)

  let $schema-presence-check :=
    if (fn:exists ($schema))
    then ()
    else (fn:error((), 'SCHEMATRON-SCHEMANOTFOUND', $schematron-uri))

  let $step1 := xdmp:xslt-invoke($INCLUDE, $schema, $params)
  let $validate-schema :=
    if (xs:string(map:get($params, "validate-schema"))="true")
    then validate full { $step1 }
    else ()

  let $step2 := xdmp:xslt-invoke($EXPAND, $step1, $params)
  let $validator-xslt := xdmp:xslt-invoke($SVRL-FOR-XSLT2, $step2, $params)
  let $validator-uri := fn:concat($schematron-uri,"-validator.xsl")
  return xdmp:eval($ml-schematron:put-validator,
    ( xs:QName("validator-uri"), $validator-uri,
      xs:QName("validator-xslt"), $validator-xslt
    ),
    <options xmlns="xdmp:eval">
      <database>{xdmp:modules-database()}</database>
    </options>)
};

(:~
 : Empty params wrapper for the schematron:validate function
 :
 : @param  $document        document node to validate
 : @param  $validator-xslt  validator-xslt node to use for validation
 : @return  output of the validation in SVRL format
 :)
declare function schematron:validate(
  $document as node(),
  $validator-xslt as document-node()
) as node()
{
  xdmp:trace($TRACE_ID, fn:concat("Inside validate#2")),
  schematron:validate($document, $validator-xslt, ())
};

(:~
 : Validator function that validates the given document against the given validator-xslt
 : one can pass in an optional map with parameters
 :
 : @param  $document        document node to validate
 : @param  $validator-xslt  validator-xslt node to use for validation
 : @return  output of the validation in SVRL format
 :)
declare function schematron:validate(
  $document as node(),
  $validator-xslt as document-node(),
  $params as map:map?
) as node()
{
  let $parameters := map:map()=>map:with("parameters", if (fn:exists($params)) then $params else map:map())
  return
    if (xdmp:node-kind($document)="document")
    then xdmp:xslt-eval($validator-xslt, $document, $parameters)
    else xdmp:xslt-eval($validator-xslt, document { $document }, $parameters)
};
----

## A working example

Now that we have all the plumbing set up it is time to do a test run.
